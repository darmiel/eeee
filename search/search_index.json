{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About EEEE* is a tiny framework for simple console input of values and generation of objects, which I wrote mainly for exercises of my university, because often simple inputs with a scanner are needed, and I did not want to rewrite them all the time. Also, I didn't use any existing frameworks, ~~because apparently we are only allowed to use self-written code in the exams, and thus I am allowed to use this mini-framework in the exams~~. EDIT: Looks like all frameworks are allowed. Well shit. NOTE: This framework is ab-so-lutely not suitable for production use. It should only serve for practice. Also, definitely not type-safe. Here , you can find some examples for some modules. Installation Maven Add the JitPack repository to your pom.xml : <repositories> <repository> <id> jitpack.io </id> <url> https://jitpack.io </url> </repository> </repositories> Add the eeee -dependency: <dependency> <groupId> com.github.darmiel </groupId> <artifactId> eeee </artifactId> <version> 2.6.0 </version> </dependency> Gradle Add the JitPack repository to your build file: allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Add the eeee -dependency: dependencies { implementation 'com.github.darmiel:eeee:2.6.0' } *) To be honest, I've already forgotten the meaning of the abbreviation. But it was certainly perfect!","title":"About"},{"location":"#about","text":"EEEE* is a tiny framework for simple console input of values and generation of objects, which I wrote mainly for exercises of my university, because often simple inputs with a scanner are needed, and I did not want to rewrite them all the time. Also, I didn't use any existing frameworks, ~~because apparently we are only allowed to use self-written code in the exams, and thus I am allowed to use this mini-framework in the exams~~. EDIT: Looks like all frameworks are allowed. Well shit. NOTE: This framework is ab-so-lutely not suitable for production use. It should only serve for practice. Also, definitely not type-safe. Here , you can find some examples for some modules.","title":"About"},{"location":"#installation","text":"Maven Add the JitPack repository to your pom.xml : <repositories> <repository> <id> jitpack.io </id> <url> https://jitpack.io </url> </repository> </repositories> Add the eeee -dependency: <dependency> <groupId> com.github.darmiel </groupId> <artifactId> eeee </artifactId> <version> 2.6.0 </version> </dependency> Gradle Add the JitPack repository to your build file: allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Add the eeee -dependency: dependencies { implementation 'com.github.darmiel:eeee:2.6.0' } *) To be honest, I've already forgotten the meaning of the abbreviation. But it was certainly perfect!","title":"Installation"},{"location":"entrypoints/01-first-entrypoint/","text":"Creating the First Entry Point Note: This GIF is already outdated, but it is still a good example. In your main method run Starter#start : public class MyMain { public static void main ( String [] args ) throws Exception { Starter . start ( MyMain . class , args ) } } Create a method with any named annotated by @Entrypoint : @Entrypoint public void run () { System . out . println ( \"Hello World!\" ); } Run the application: Hello World! Now let's create even more entry points: @Entrypoint ( \"Hello World\" ) public void runHelloWorld () { System . out . println ( \"Hello World!\" ); } @Entrypoint ( \"Joke\" ) public void runJoke () { System . out . println ( \"Why did the programmier quit his job? Because he didn't get arrays.\" ); } If the application is now run again, we will be asked at startup which entrypoint we want to start: 1. GettingStarted::Hello World@runHelloWorld () 2. GettingStarted::Joke@runJoke () \ud83e\ude84 Select Method to run [1-2/{name}]: runJoke Why did the programmier quit his job? Because he didn't get arrays. Attributes for @Entrypoint @Entrypoint ( value = \"xyz\" ) // value: display name of the entrypoint @Entrypoint ( loop = true ) // loop: true = run the entrypoint again after it has finished @Entrypoint ( stopwatch = true ) // stopwatch: true = print the time it took to run the entrypoint @Entrypoint ( verbose = true ) // verbose: true = print debugging information","title":"Creating the First Entry Point"},{"location":"entrypoints/01-first-entrypoint/#creating-the-first-entry-point","text":"Note: This GIF is already outdated, but it is still a good example. In your main method run Starter#start : public class MyMain { public static void main ( String [] args ) throws Exception { Starter . start ( MyMain . class , args ) } } Create a method with any named annotated by @Entrypoint : @Entrypoint public void run () { System . out . println ( \"Hello World!\" ); } Run the application: Hello World! Now let's create even more entry points: @Entrypoint ( \"Hello World\" ) public void runHelloWorld () { System . out . println ( \"Hello World!\" ); } @Entrypoint ( \"Joke\" ) public void runJoke () { System . out . println ( \"Why did the programmier quit his job? Because he didn't get arrays.\" ); } If the application is now run again, we will be asked at startup which entrypoint we want to start: 1. GettingStarted::Hello World@runHelloWorld () 2. GettingStarted::Joke@runJoke () \ud83e\ude84 Select Method to run [1-2/{name}]: runJoke Why did the programmier quit his job? Because he didn't get arrays. Attributes for @Entrypoint @Entrypoint ( value = \"xyz\" ) // value: display name of the entrypoint @Entrypoint ( loop = true ) // loop: true = run the entrypoint again after it has finished @Entrypoint ( stopwatch = true ) // stopwatch: true = print the time it took to run the entrypoint @Entrypoint ( verbose = true ) // verbose: true = print debugging information","title":"Creating the First Entry Point"},{"location":"entrypoints/02-prompts/","text":"Prompts Any number of parameters can be passed to an entrypoint. The user is then asked to enter these parameters when the program is started. Use the @Prompt annotation to change the prompt. @Entrypoint public void run ( @Prompt ( \"Enter your name\" ) final String name ) { System . out . printf ( \"Hello %s!%n\" , name ); } [String] Enter your name > Daniel Hello Daniel! Natively Supported Types boolean / Boolean char / Character double / Double int / Integer short / Short String Special Wrappers: Arrays of the above types Scanner Default Values Default values can be set for parameters using the @Default -annotation: @Entrypoint public void run ( @Prompt ( \"Name\" ) @Default ( \"Simon\" ) final String name ) { System . out . printf ( \"Hello %s!%n\" , name ); } If no value is entered, the default value is used. [String] Name [Simon] > (enter) Hello Simon! Note Only inputs as string are possible. Enter as default value exactly what you expect from the user. Arrays (see ArrayPromptExample.java ) As announced above, it is possible to pass arrays. An array is then filled with values entered by the user with a separator (comma by default): @Entrypoint public void run ( @Prompt ( \"Enter Numbers\" ) @Split ( \" \" ) final int [] numbers ) { System . out . println ( Arrays . toString ( numbers )); } [arr<int>] / / Enter Numbers > 1 8 2 9 3 [1, 8, 2, 9, 3] Note Validators do not work for values inside the array. For example, @Range only limits the array size, not the individual values.","title":"Prompts"},{"location":"entrypoints/02-prompts/#prompts","text":"Any number of parameters can be passed to an entrypoint. The user is then asked to enter these parameters when the program is started. Use the @Prompt annotation to change the prompt. @Entrypoint public void run ( @Prompt ( \"Enter your name\" ) final String name ) { System . out . printf ( \"Hello %s!%n\" , name ); } [String] Enter your name > Daniel Hello Daniel! Natively Supported Types boolean / Boolean char / Character double / Double int / Integer short / Short String Special Wrappers: Arrays of the above types Scanner","title":"Prompts"},{"location":"entrypoints/02-prompts/#default-values","text":"Default values can be set for parameters using the @Default -annotation: @Entrypoint public void run ( @Prompt ( \"Name\" ) @Default ( \"Simon\" ) final String name ) { System . out . printf ( \"Hello %s!%n\" , name ); } If no value is entered, the default value is used. [String] Name [Simon] > (enter) Hello Simon! Note Only inputs as string are possible. Enter as default value exactly what you expect from the user.","title":"Default Values"},{"location":"entrypoints/02-prompts/#arrays","text":"(see ArrayPromptExample.java ) As announced above, it is possible to pass arrays. An array is then filled with values entered by the user with a separator (comma by default): @Entrypoint public void run ( @Prompt ( \"Enter Numbers\" ) @Split ( \" \" ) final int [] numbers ) { System . out . println ( Arrays . toString ( numbers )); } [arr<int>] / / Enter Numbers > 1 8 2 9 3 [1, 8, 2, 9, 3] Note Validators do not work for values inside the array. For example, @Range only limits the array size, not the individual values.","title":"Arrays"},{"location":"entrypoints/03-validation/","text":"Validation (see ValidationExample.java ) A few types can be validated. For numbers, for example, the default is to check whether the input is a number: @Entrypoint public void run ( @Prompt ( \"Number of iterations\" ) final int number ) { for ( int i = 0 ; i < number ; i ++ ) { System . out . println ( i ); } } [int] Number of iterations > Test \ud83e\udd91 [wrap-error] For input string: \"Test\" [int] Number of iterations > 2 // OK! ... @Range The size of numbers, the length of strings, and the capacity of arrays can be limited with the @Range -annotation: @Entrypoint public void run ( @Range ({ 0 , 10 }) final int number , @Range ({ 2 , 25 }) final String name ) { // ... } @Pattern Strings can be validated with a regular expression using the @Pattern -annotation: @Entrypoint public void run ( @Pattern ( \"^[A-Ha-h]{5}$\" ) final String name ) { // hbHah: allowed // zeZez: not allowed } @Transform Strings can additionally be transformed with the @Transform -annotation, e.g. UPPER_CASE, lower_case and desreveR: @Entrypoint public void run ( @Transform ( Type . UPPER ) final String name @Transform ({ Type . LOWER , Type . REVERSE }) final String name2 ) { // ... }","title":"Validation"},{"location":"entrypoints/03-validation/#validation","text":"(see ValidationExample.java ) A few types can be validated. For numbers, for example, the default is to check whether the input is a number: @Entrypoint public void run ( @Prompt ( \"Number of iterations\" ) final int number ) { for ( int i = 0 ; i < number ; i ++ ) { System . out . println ( i ); } } [int] Number of iterations > Test \ud83e\udd91 [wrap-error] For input string: \"Test\" [int] Number of iterations > 2 // OK! ... @Range The size of numbers, the length of strings, and the capacity of arrays can be limited with the @Range -annotation: @Entrypoint public void run ( @Range ({ 0 , 10 }) final int number , @Range ({ 2 , 25 }) final String name ) { // ... } @Pattern Strings can be validated with a regular expression using the @Pattern -annotation: @Entrypoint public void run ( @Pattern ( \"^[A-Ha-h]{5}$\" ) final String name ) { // hbHah: allowed // zeZez: not allowed } @Transform Strings can additionally be transformed with the @Transform -annotation, e.g. UPPER_CASE, lower_case and desreveR: @Entrypoint public void run ( @Transform ( Type . UPPER ) final String name @Transform ({ Type . LOWER , Type . REVERSE }) final String name2 ) { // ... }","title":"Validation"},{"location":"entrypoints/04-calling-other-entrypoints/","text":"Calling other Entrypoints (see CallExample.java ) If you want to use an entrypoint e.g. as a template to give a user selection, an entrypoint can be called by prepending a parameter @Entrypoint with the exact name of the entrypoint to be called, and using the type Call<type of entrypoint> . The specified entrypoint will then be called when the Call#call is invoked: @Entrypoint ( \"__get_name\" ) public String runGetName ( @Prompt ( \"Enter Name\" ) final String name ) { return name ; } @Entrypoint public void run ( @Entrypoint ( \"__get_name\" ) final Call < String > nameCall ) { for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( \"Name \" + ( i + 1 ) + \": \" + nameCall . call ()); } } [String] Enter Name > Daniel Name 1: Daniel [String] Enter Name > Test2 Name 2: Test2 [String] Enter Name > Test4 // ...","title":"Calling other Entrypoints"},{"location":"entrypoints/04-calling-other-entrypoints/#calling-other-entrypoints","text":"(see CallExample.java ) If you want to use an entrypoint e.g. as a template to give a user selection, an entrypoint can be called by prepending a parameter @Entrypoint with the exact name of the entrypoint to be called, and using the type Call<type of entrypoint> . The specified entrypoint will then be called when the Call#call is invoked: @Entrypoint ( \"__get_name\" ) public String runGetName ( @Prompt ( \"Enter Name\" ) final String name ) { return name ; } @Entrypoint public void run ( @Entrypoint ( \"__get_name\" ) final Call < String > nameCall ) { for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( \"Name \" + ( i + 1 ) + \": \" + nameCall . call ()); } } [String] Enter Name > Daniel Name 1: Daniel [String] Enter Name > Test2 Name 2: Test2 [String] Enter Name > Test4 // ...","title":"Calling other Entrypoints"},{"location":"entrypoints/05-prompt-interfaces/","text":"Prompt Interface (see PromptFactoryExample.java ) An alternative would be to create an interface, write the prompts there, and then pass this interface using the @Factory annotation: public interface Wiz { @Prompt ( \"Enter Name\" ) String getName (); } @Entrypoint public void run ( @Factory final Wiz wiz ) { for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( \"Name \" + ( i + 1 ) + \": \" + wiz . getName ()); } }","title":"Prompt Interface"},{"location":"entrypoints/05-prompt-interfaces/#prompt-interface","text":"(see PromptFactoryExample.java ) An alternative would be to create an interface, write the prompts there, and then pass this interface using the @Factory annotation: public interface Wiz { @Prompt ( \"Enter Name\" ) String getName (); } @Entrypoint public void run ( @Factory final Wiz wiz ) { for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( \"Name \" + ( i + 1 ) + \": \" + wiz . getName ()); } }","title":"Prompt Interface"},{"location":"entrypoints/06-custom-types/","text":"Custom Types If you want to have your own class created using a prompt, you can solve this by implementing the RawWrapper<T> interface. public static class Rectangle implements RawWrapper < Rectangle > { private final int height ; private final int width ; // ... @Override public Rectangle wrap ( final WrapContext ctx ) { System . out . println ( \"Rectangle#wrap called!\" ); return /* ... */ ; } } @Entrypoint public void run ( final Rectangle rect ) { System . out . println ( rect ); } Rectangle#wrap called! // ...","title":"Custom Types"},{"location":"entrypoints/06-custom-types/#custom-types","text":"If you want to have your own class created using a prompt, you can solve this by implementing the RawWrapper<T> interface. public static class Rectangle implements RawWrapper < Rectangle > { private final int height ; private final int width ; // ... @Override public Rectangle wrap ( final WrapContext ctx ) { System . out . println ( \"Rectangle#wrap called!\" ); return /* ... */ ; } } @Entrypoint public void run ( final Rectangle rect ) { System . out . println ( rect ); } Rectangle#wrap called! // ...","title":"Custom Types"},{"location":"generators/01-generators/","text":"Generators (see Generator Examples ) Sample objects can be created using @Generate . Note: This GIF is already outdated, but it is still a good example. Prepare class to be generated A class can be automatically initialized with random values by prepending the @Generate -annotation to at least one constructor: public static class Person { private final String name ; private final int age ; @Generate // <-- required public Person ( final String name , final int age ) { this . name = name ; this . age = age ; } } A class can now be generated by writing the class to be generated in an entrypoint with a prescribed @Generate -annotation: @Entrypoint public void run ( @Generate final Person person ) { System . out . println ( person ); // Person{name='kiMf', age=2} } Generating single instance without an entry point If you only want to use the Generate function, you can use the RandomFactory class to generate values: public static void main ( final String [] args ) throws Exception { final Person person = RandomFactory . generate ( Person . class ); System . out . println ( person ); } If you want to create multiple instances, change the type to an array and add the @Fill -annotation to specify the amount of instances to be created: @Entrypoint public void run ( @Generate @Fill ( 5 ) final Person [] person ) { System . out . println ( Arrays . toString ( person )); // [Person{name='HCx', age=4}, Person{name='JTn', age=1}, Person{name='ahNF', age=2}, Person{name='VcuDX', age=1}, Person{name='vIMcBD', age=10}] } Generating array without an entry point If you only want to use the Generate function, you can use the RandomFactory class to generate values: public static void main ( final String [] args ) throws Exception { final Person [] person = new Person [ 5 ] ; RandomFactory . fill ( person ); System . out . println ( Arrays . toString ( person )); } Supported Types Natively Supported Generate Types boolean / Boolean char / Character double / Double int / Integer String Special Generators: Arrays of the above types These types can also be generated directly inline: @Entrypoint public void run ( @Generate final int [] numbers ) { System . out . println ( Arrays . toString ( numbers )); }","title":"Generators"},{"location":"generators/01-generators/#generators","text":"(see Generator Examples ) Sample objects can be created using @Generate . Note: This GIF is already outdated, but it is still a good example.","title":"Generators"},{"location":"generators/01-generators/#prepare-class-to-be-generated","text":"A class can be automatically initialized with random values by prepending the @Generate -annotation to at least one constructor: public static class Person { private final String name ; private final int age ; @Generate // <-- required public Person ( final String name , final int age ) { this . name = name ; this . age = age ; } } A class can now be generated by writing the class to be generated in an entrypoint with a prescribed @Generate -annotation: @Entrypoint public void run ( @Generate final Person person ) { System . out . println ( person ); // Person{name='kiMf', age=2} } Generating single instance without an entry point If you only want to use the Generate function, you can use the RandomFactory class to generate values: public static void main ( final String [] args ) throws Exception { final Person person = RandomFactory . generate ( Person . class ); System . out . println ( person ); } If you want to create multiple instances, change the type to an array and add the @Fill -annotation to specify the amount of instances to be created: @Entrypoint public void run ( @Generate @Fill ( 5 ) final Person [] person ) { System . out . println ( Arrays . toString ( person )); // [Person{name='HCx', age=4}, Person{name='JTn', age=1}, Person{name='ahNF', age=2}, Person{name='VcuDX', age=1}, Person{name='vIMcBD', age=10}] } Generating array without an entry point If you only want to use the Generate function, you can use the RandomFactory class to generate values: public static void main ( final String [] args ) throws Exception { final Person [] person = new Person [ 5 ] ; RandomFactory . fill ( person ); System . out . println ( Arrays . toString ( person )); }","title":"Prepare class to be generated"},{"location":"generators/01-generators/#supported-types","text":"Natively Supported Generate Types boolean / Boolean char / Character double / Double int / Integer String Special Generators: Arrays of the above types These types can also be generated directly inline: @Entrypoint public void run ( @Generate final int [] numbers ) { System . out . println ( Arrays . toString ( numbers )); }","title":"Supported Types"},{"location":"generators/02-customize-generators/","text":"Customize Generators The generated values can be adjusted using the following annotations. If an annotation is written above the constructor, it is usually applied to all parameters within the constructor , should the parameter not have its own annotation. @Use With the Use Annotation a specific generator can be selected. When @Use is applied to an array, the specified generator is applied to the individual values within the array. (String) Name Generator EEEE has a generator for (human) names: NameGenerator @Generate public MyClass ( @Use ( NameGenerator . class ) final String name ) { // could be James, Mary, John, ... } @Range Limits the size of the generated value. @Range({min, max, step}) Steps For generators, a third argument can be used: the step. This specifies the steps in which the number is to be generated. This is very helpful with doubles, for example, to limit the precision. public MyClass ( @Range ( 0 , 1 , 0.2 ) final double value ) { // value could be 0, 0.2, 0.4, 0.6, 0.8, and 1 } @Transform Transforms a generated string. Same as the @Transform -annotation in the Validation section.","title":"Customize Generators"},{"location":"generators/02-customize-generators/#customize-generators","text":"The generated values can be adjusted using the following annotations. If an annotation is written above the constructor, it is usually applied to all parameters within the constructor , should the parameter not have its own annotation.","title":"Customize Generators"},{"location":"generators/02-customize-generators/#use","text":"With the Use Annotation a specific generator can be selected. When @Use is applied to an array, the specified generator is applied to the individual values within the array. (String) Name Generator EEEE has a generator for (human) names: NameGenerator @Generate public MyClass ( @Use ( NameGenerator . class ) final String name ) { // could be James, Mary, John, ... }","title":"@Use"},{"location":"generators/02-customize-generators/#range","text":"Limits the size of the generated value. @Range({min, max, step}) Steps For generators, a third argument can be used: the step. This specifies the steps in which the number is to be generated. This is very helpful with doubles, for example, to limit the precision. public MyClass ( @Range ( 0 , 1 , 0.2 ) final double value ) { // value could be 0, 0.2, 0.4, 0.6, 0.8, and 1 }","title":"@Range"},{"location":"generators/02-customize-generators/#transform","text":"Transforms a generated string. Same as the @Transform -annotation in the Validation section.","title":"@Transform"},{"location":"generators/03-preventing-soe/","text":"Prevent Stack Overflow Exceptions Let's have a look at this generator: public static class OverflowingPerson { private final String name ; private final OverflowingPerson next ; @Generate public OverflowingPerson ( @Use ( NameGenerator . class ) final String name , final OverflowingPerson next ) { this . name = name ; this . next = next ; } } Here a StackOverflowException would occur, because OverflowingPerson ( next ) is generated recursively. There are two ways to fix this: 1. Use @Depth The @Depth -annotation specifies what the maximum depth may be for a generated object. @Generate public OverflowingPerson ( @Use ( NameGenerator . class ) final String name , @Depth ( 2 ) final OverflowingPerson next ) { // ... } A stack overflow exception would not occur now, because in the 2nd OverflowingPerson next is not generated, thus null . 2. Use multiple @Generate constructors public static class OverflowingPerson { private final String name ; private final OverflowingPerson next ; @Generate public OverflowingPerson ( @Use ( NameGenerator . class ) final String name , @Generate ( \"next\" ) final OverflowingPerson next ) { this . name = name ; this . next = next ; } @Generate ( \"next\" ) public OverflowingPerson ( @Use ( NameGenerator . class ) final String name ) { this . name = name ; this . next = null ; } }","title":"Prevent Stack Overflow Exceptions"},{"location":"generators/03-preventing-soe/#prevent-stack-overflow-exceptions","text":"Let's have a look at this generator: public static class OverflowingPerson { private final String name ; private final OverflowingPerson next ; @Generate public OverflowingPerson ( @Use ( NameGenerator . class ) final String name , final OverflowingPerson next ) { this . name = name ; this . next = next ; } } Here a StackOverflowException would occur, because OverflowingPerson ( next ) is generated recursively. There are two ways to fix this:","title":"Prevent Stack Overflow Exceptions"},{"location":"generators/03-preventing-soe/#1-use-depth","text":"The @Depth -annotation specifies what the maximum depth may be for a generated object. @Generate public OverflowingPerson ( @Use ( NameGenerator . class ) final String name , @Depth ( 2 ) final OverflowingPerson next ) { // ... } A stack overflow exception would not occur now, because in the 2nd OverflowingPerson next is not generated, thus null .","title":"1. Use @Depth"},{"location":"generators/03-preventing-soe/#2-use-multiple-generate-constructors","text":"public static class OverflowingPerson { private final String name ; private final OverflowingPerson next ; @Generate public OverflowingPerson ( @Use ( NameGenerator . class ) final String name , @Generate ( \"next\" ) final OverflowingPerson next ) { this . name = name ; this . next = next ; } @Generate ( \"next\" ) public OverflowingPerson ( @Use ( NameGenerator . class ) final String name ) { this . name = name ; this . next = null ; } }","title":"2. Use multiple @Generate constructors"},{"location":"legacy-docs/injector/","text":"Injection The framework includes a Mini-Injector functionality. Injected values can be used in entrypoint classes by default: import io.d2a.eeee.annotation.annotations.prompt.Entrypoint ; import io.d2a.eeee.inject.Inject ; public class App { @Inject private Scanner scanner ; // scanner which asks for user input // or: private final String [] args ; public App ( @Inject ( \"args\" ) final String [] args ) { this . args = args ; } @Entrypoint public void hello () { final String line = this . scanner . nextLine (); System . out . println ( line ); } } Default injectable values: Type Scanner , Name: None ( @Inject Scanner scanner ) Type: String[] , Name: args ( @Inject(\"args\") String[] args ) Custom Injection import io.d2a.eeee.inject.Inject ; public class App { @Inject ( \"name\" ) private String name ; private final int age ; public App ( @Inject int age ) { this . age = age ; } public static void main ( String [] args ) { final Injector injector = new Injector () . register ( String . class , \"Thorsten\" , \"name\" ) . register ( int . class , 22 ); final App app = injector . create ( App . class ); app . print (); } public void print () { System . out . printf ( \"%s is %d.%n\" , this . name , this . age ); } }","title":"Injection"},{"location":"legacy-docs/injector/#injection","text":"The framework includes a Mini-Injector functionality. Injected values can be used in entrypoint classes by default: import io.d2a.eeee.annotation.annotations.prompt.Entrypoint ; import io.d2a.eeee.inject.Inject ; public class App { @Inject private Scanner scanner ; // scanner which asks for user input // or: private final String [] args ; public App ( @Inject ( \"args\" ) final String [] args ) { this . args = args ; } @Entrypoint public void hello () { final String line = this . scanner . nextLine (); System . out . println ( line ); } } Default injectable values: Type Scanner , Name: None ( @Inject Scanner scanner ) Type: String[] , Name: args ( @Inject(\"args\") String[] args )","title":"Injection"},{"location":"legacy-docs/injector/#custom-injection","text":"import io.d2a.eeee.inject.Inject ; public class App { @Inject ( \"name\" ) private String name ; private final int age ; public App ( @Inject int age ) { this . age = age ; } public static void main ( String [] args ) { final Injector injector = new Injector () . register ( String . class , \"Thorsten\" , \"name\" ) . register ( int . class , 22 ); final App app = injector . create ( App . class ); app . print (); } public void print () { System . out . printf ( \"%s is %d.%n\" , this . name , this . age ); } }","title":"Custom Injection"},{"location":"utils/nullchain/","text":"Null-Chain Emulates Optional Chaining ( ?. ) for Java. Example (JavaScript): const val = obj ? . owner ? . name ; Example (NullChain): final String name = NullChain . of ( obj ). then ( Obj :: owner ). then ( Person :: name ). orNull (); If the value is null in any then -step, null is returned. So you don't have to worry about whether an NPE could be thrown. Psychopaths can also use the yolo() method, for a shorter syntax, but at what cost... final String name = NullChain . yolo (() -> obj . owner . name );","title":"Null-Chain"},{"location":"utils/nullchain/#null-chain","text":"Emulates Optional Chaining ( ?. ) for Java. Example (JavaScript): const val = obj ? . owner ? . name ; Example (NullChain): final String name = NullChain . of ( obj ). then ( Obj :: owner ). then ( Person :: name ). orNull (); If the value is null in any then -step, null is returned. So you don't have to worry about whether an NPE could be thrown. Psychopaths can also use the yolo() method, for a shorter syntax, but at what cost... final String name = NullChain . yolo (() -> obj . owner . name );","title":"Null-Chain"},{"location":"utils/table/","text":"Tables Create an object which represents a row: @HeaderOrder ({ \"First Name\" , \"Age\" }) // specifies the sorting of the headers // this is optional, but if you don't include this, // the order of the columns is \"random\" public static class Person { @Column ( \"First Name\" ) // must be same as in HeaderOrder public final String first ; @Column ( \"Age\" ) // must be same as in HeaderOrder public final int age ; } Create table final Person [] people = new Person [ 5 ] ; RandomFactory . fill ( people ); // generate random person objects // create table and fill with array final Table table = TableBuilder . from ( people , Person . class ) . color ( true ) . style ( TableStyle . ROUND ); System . out . println ( table ); Output (note: may be broken on some browsers) \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u256e \u2502 First Name \u2502 Age \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Margaret \u2502 42 \u2502 \u2502 Michael \u2502 79 \u2502 \u2502 Anna \u2502 43 \u2502 \u2502 Cynthia \u2502 50 \u2502 \u2502 Margaret \u2502 82 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256f Without Annotations final Person [] people = new Person [ 5 ] ; RandomFactory . fill ( people ); final Table x = TableBuilder . builder ( \"Name\" , \"Age\" ) . loads ( Arrays . asList ( people ), person -> TableBuilder . array ( person . first , String . valueOf ( person . age )) ) . build (); Example ( PeriodicTable.java ) Output (note: may be broken on some browsers) \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Name \u2502 Symbol \u2502 Ordinal \u2502 Shell \u2502 Phase \u2502 Group \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Wasserstoff \u2502 H \u2502 1 \u2502 K \u2502 3 \u2502 true \u2502 \u2502 Helium \u2502 He \u2502 2 \u2502 K \u2502 3 \u2502 true \u2502 \u2502 Natrium \u2502 Na \u2502 11 \u2502 M \u2502 1 \u2502 true \u2502 \u2502 Eisen \u2502 Fe \u2502 26 \u2502 N \u2502 1 \u2502 false \u2502 \u2502 Germanium \u2502 Ge \u2502 32 \u2502 N \u2502 1 \u2502 false \u2502 \u2502 Brom \u2502 Br \u2502 35 \u2502 N \u2502 2 \u2502 true \u2502 \u2502 Tellur \u2502 Te \u2502 52 \u2502 O \u2502 1 \u2502 true \u2502 \u2502 Gold \u2502 Au \u2502 79 \u2502 P \u2502 1 \u2502 false \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Tables"},{"location":"utils/table/#tables","text":"Create an object which represents a row: @HeaderOrder ({ \"First Name\" , \"Age\" }) // specifies the sorting of the headers // this is optional, but if you don't include this, // the order of the columns is \"random\" public static class Person { @Column ( \"First Name\" ) // must be same as in HeaderOrder public final String first ; @Column ( \"Age\" ) // must be same as in HeaderOrder public final int age ; } Create table final Person [] people = new Person [ 5 ] ; RandomFactory . fill ( people ); // generate random person objects // create table and fill with array final Table table = TableBuilder . from ( people , Person . class ) . color ( true ) . style ( TableStyle . ROUND ); System . out . println ( table ); Output (note: may be broken on some browsers) \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u256e \u2502 First Name \u2502 Age \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Margaret \u2502 42 \u2502 \u2502 Michael \u2502 79 \u2502 \u2502 Anna \u2502 43 \u2502 \u2502 Cynthia \u2502 50 \u2502 \u2502 Margaret \u2502 82 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256f","title":"Tables"},{"location":"utils/table/#without-annotations","text":"final Person [] people = new Person [ 5 ] ; RandomFactory . fill ( people ); final Table x = TableBuilder . builder ( \"Name\" , \"Age\" ) . loads ( Arrays . asList ( people ), person -> TableBuilder . array ( person . first , String . valueOf ( person . age )) ) . build ();","title":"Without Annotations"},{"location":"utils/table/#example","text":"( PeriodicTable.java ) Output (note: may be broken on some browsers) \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Name \u2502 Symbol \u2502 Ordinal \u2502 Shell \u2502 Phase \u2502 Group \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Wasserstoff \u2502 H \u2502 1 \u2502 K \u2502 3 \u2502 true \u2502 \u2502 Helium \u2502 He \u2502 2 \u2502 K \u2502 3 \u2502 true \u2502 \u2502 Natrium \u2502 Na \u2502 11 \u2502 M \u2502 1 \u2502 true \u2502 \u2502 Eisen \u2502 Fe \u2502 26 \u2502 N \u2502 1 \u2502 false \u2502 \u2502 Germanium \u2502 Ge \u2502 32 \u2502 N \u2502 1 \u2502 false \u2502 \u2502 Brom \u2502 Br \u2502 35 \u2502 N \u2502 2 \u2502 true \u2502 \u2502 Tellur \u2502 Te \u2502 52 \u2502 O \u2502 1 \u2502 true \u2502 \u2502 Gold \u2502 Au \u2502 79 \u2502 P \u2502 1 \u2502 false \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Example"}]}